document.addEventListener('DOMContentLoaded', () => {
    // Referencias a elementos del DOM
    const imageLoader = document.getElementById('image-loader');
    const fileNameSpan = document.getElementById('file-name');
    const adjustmentsDiv = document.getElementById('adjustments');
    const processBtn = document.getElementById('process-btn');
    const statusBar = document.getElementById('status-bar');
    const canvas = document.getElementById('image-canvas');
    const ctx = canvas.getContext('2d');
    const paletteContainer = document.getElementById('palette-container');
    const loader = document.getElementById('loader');

    let originalImageFile = null;

    // Actualizar dinámicamente los valores de los sliders
    document.querySelectorAll('input[type="range"]').forEach(slider => {
        const valueSpan = document.getElementById(`${slider.id}-value`);
        if (valueSpan) {
            slider.addEventListener('input', () => {
                valueSpan.textContent = slider.value;
            });
        }
    });
    
    // Manejar la carga de la imagen
    imageLoader.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            originalImageFile = file;
            fileNameSpan.textContent = file.name;
            adjustmentsDiv.classList.remove('hidden');
            processBtn.disabled = false;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Muestra la imagen original como vista previa
                    const MAX_WIDTH = canvas.parentElement.clientWidth;
                    const MAX_HEIGHT = canvas.parentElement.clientHeight;
                    let { width, height } = img;
                    if (width > height) {
                        if (width > MAX_WIDTH) {
                            height *= MAX_WIDTH / width;
                            width = MAX_WIDTH;
                        }
                    } else {
                        if (height > MAX_HEIGHT) {
                            width *= MAX_HEIGHT / height;
                            height = MAX_HEIGHT;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, width, height);
                    updateStatus('Image loaded. Adjust settings and click "Generate Image!".');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    // Manejar el clic en el botón de procesar
    processBtn.addEventListener('click', async () => {
        if (!originalImageFile) {
            updateStatus('Please select an image first.', true);
            return;
        }

        // Mostrar loader y deshabilitar botón
        loader.classList.remove('hidden');
        processBtn.disabled = true;
        updateStatus('Processing... This may take a moment, especially for background removal.');

        // Crear FormData para enviar la imagen y los ajustes
        const formData = new FormData();
        formData.append('image', originalImageFile);
        
        // Añadir todos los valores de los controles
        document.querySelectorAll('#adjustments input').forEach(input => {
            if (input.type === 'checkbox') {
                formData.append(input.id.replace(/-/g, '_'), input.checked);
            } else if (input.type === 'range' || input.type === 'number') {
                formData.append(input.id.replace(/-/g, '_'), input.value);
            }
        });
        
        try {
            // Enviar la petición al backend (Flask)
            const response = await fetch('/process-image', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Server error');
            }

            const data = await response.json();
            
            // Actualizar la imagen en el canvas con el resultado
            const resultImage = new Image();
            resultImage.onload = () => {
                canvas.width = resultImage.width;
                canvas.height = resultImage.height;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(resultImage, 0, 0);
            };
            resultImage.src = 'data:image/png;base64,' + data.image;

            // Actualizar la paleta de colores
            displayPalette(data.palette);
            updateStatus(data.message);

        } catch (error) {
            console.error('Error:', error);
            updateStatus(`Error: ${error.message}`, true);
        } finally {
            // Ocultar loader y habilitar botón
            loader.classList.add('hidden');
            processBtn.disabled = false;
        }
    });

    function displayPalette(palette) {
        paletteContainer.innerHTML = ''; // Limpiar paleta anterior
        if (palette.length === 0) {
            paletteContainer.textContent = 'No colors found in the processed image.';
            return;
        }
        palette.forEach(colorHex => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch';
            swatch.style.backgroundColor = colorHex;
            swatch.title = colorHex; // Muestra el código al pasar el ratón
            paletteContainer.appendChild(swatch);
        });
    }

    function updateStatus(message, isError = false) {
        statusBar.textContent = message;
        statusBar.style.color = isError ? 'red' : 'black';
    }
});